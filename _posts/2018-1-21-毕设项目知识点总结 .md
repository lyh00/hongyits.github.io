---
layout: post
title: "毕设项目知识点总结"
date: 2018-1-4 
description: "一一一一一"
tag: 毕设
---   
## 1、service层不要trycatch
如果用了trycatch，并发生了错误，然后没有向外继续抛异常，切面的事务会依旧提交。

## 2、Ajax跨域请求
因为同源策略，浏览器不能实现跨域请求。但是JS有一个特性---> JS方法可以跨域加载JS文件(可以加载不同源的JS文件)，更详细的说就是利用 script 标签没有跨域限制的“漏洞”。所以可以通过 script src="" 绕过浏览器的限制。具体实现方法时 先可以在本地写一个JS方法，然后在动态告诉后台这个方法的名字跟需要什么数据，然后在远程服务器上生成这个方法。之后在本地再手动新建一个  script标签 来远程调用这个方法。
[JSON跟JSONP的介绍](http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html)
![](/images/posts/SSM/kuayu.png)

## 3、关于 in 跟 exists 哪个效率更高的问题

因为in会使用你的子查询字段去到主表匹配你需要的行，而exists是根据匹配项去判断是或者否，然后根据是否决定结果，子查询的表大，用exists判断，效率就会高，而当子查询很小的时候，直接匹配你需要的值则更快。比如主表4万行，子查询里面有5条数据，那么exists会把4万行在子查询里面进行匹配，匹配上了就显示，匹配不上就不显示，所以需要判断4万次，而in则会在主表4万行里面去检索这5条记录，由于索引等等的存在，in的效率通常会更高，但是如果反过来，主表5条记录，子查询里面有4万行，exists只进行5次判断，而in会用4万个数据去匹配这5条记录，当然exists更快。

## 4、Java高效并发之乐观锁悲观锁、（互斥同步、非互斥同步）
[Java高效并发之乐观锁悲观锁、（互斥同步、非互斥同步)](http://blog.csdn.net/truelove12358/article/details/54963791)
[乐观锁悲观锁的使用选择](http://blog.csdn.net/qq32933432/article/details/51036361)
一句话总结就是：像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。

## 5、